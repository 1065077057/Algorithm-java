/*动态规划-edit distance*/

/*
分析：
    动态规划中比较经典的一个问题。其实跟动态规划求子串差不多。
求子串时，获得的是 edit distance 的前提：相似性。edit distance
就要求通过差异性来获得编辑的次数。
	同样是列矩阵，当两个字符串相同的时候，编辑距离为 0 那么就
编辑次数是不变的。如果两者不同，那么就要增加一次编辑次数，增
加的方式取决于上下两个位置。
*/

/*
算法实现以及与求子串的代码差异：
	矩阵长宽仍然要+1，求子串保留的都是 0 ，而 edit distance 保
留的是 0 - a.length 与 0 - b.length。
	如果元素相同，x[i][j] = x[i-1][j-1]
	如果元素不同，x[i][j] = min(x[i][j-1]+1,x[i-1][j]+1,x[i-1][j-1]+1)
	最后：x[a.length-1][b.length-1] 位置的数，就是编辑次数，即：
edit distance
*/

/*
根据博客与书：
对于如下两个strings：
X的长度为n
Y的长度为m
	我们定义D（i，j）为 X 的前i个字符 X[1...i] 与 Y 的前j个字符 Y[1...j] 之间的距离，
其中0<i<n, 0<j<m，因此X与Y的距离可以用D(n,m)来表示。
	假如我们想要计算最终的D(n,m)，那么可以从头开始，先计算D(i, j) （i和j从1开始）的
值，然后基于前面的结果计算更大的D(i, j)，直到最终求得D(n,m)。
D(i,j)可能的取值为:
1. D(i-1, j) +1 ；
2. D(i, j-1) +1 ；
3. D(i-1, j-1) + 2 (当X新增加的字符和Y新增加的字符不同时，需要替换）或者 + 0（即两个字符串新增加的字符相同）
*/

/*Java 实现代码，最后输出的是矩阵便于理解*/
import java.util.Scanner;

public class Main {
	public static int min(int a,int b,int c){
		int minnum = a;
		if(minnum > b){
			minnum = b;
		}
		if(minnum > c){
			minnum = c;
		}
		return minnum;
	}
	
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		
		String a = input.next();
		String b = input.next();
		int al = a.length();
		int bl = b.length();
		int[][] x = new int[al+1][bl+1];
		
		for(int i = 1;i <= al;i++){
			x[i][0] = i;
		}
		for(int i = 1;i <= bl;i++){
			x[0][i] = i;
		}
		
		for(int i = 1;i <= al;i++){
			for(int j = 1;j <= bl;j++){
				if(a.charAt(i-1) == b.charAt(j-1)){
					x[i][j] = x[i-1][j-1];
				}else{
					x[i][j] = min(x[i-1][j-1],x[i-1][j],x[i][j-1])+1;
				}
			}
		}
		for(int i = 0;i <= al;i++){
			for(int j = 0;j <= bl;j++){
				System.out.printf("%d ",x[i][j]);
			}
			System.out.println();
		}	
	}
}
